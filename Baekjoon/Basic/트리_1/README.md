Tree 1
======

Baekjoon Online Judge 초급 Ch07. 트리 1
-------------------------------------

#### 문제

* [트리 순회](./트리_순회) [[1991번 상세보기](https://www.acmicpc.net/problem/1991)]
* 트리의 부모 찾기 [[11725번 상세보기](https://www.acmicpc.net/problem/11725)]
* 트리의 지름 [[1167번 상세보기](https://www.acmicpc.net/problem/1167)]
* 트리의 지름 [[1967번 상세보기](https://www.acmicpc.net/problem/1967)]

### 풀이 전 알아야 할 개념

#### 트리의 용어

트리 (Tree) 는 **사이클이 없는 그래프** 를 나타냅니다.  
정점의 개수가 V개라면, 간선의 개수는 V - 1개 이며, 모든 정점이 연결되어있을 경우에 트리라고 할 수 있습니다.  

* 루트 있는 트리 (Rooted Tree)
    * 트리는 루트 (Root) 를 기준으로 방향을 지정
* 부모 (Parent) 와 자식 (Children)
    * 루트에 가까우며 인접한 노드가 부모
    * 루트는 부모가 존재하지 않음
* 단말 정점 (Leaf Node)
    * Terminal Node 라고도 함
    * 자식이 존재하지 않음
* 형제 (Sibling)
    * 같은 부모를 가지는 자식 노드들
* 깊이 (Depth)
    * Level 이라고도 함
    * 루트에서 해당 노드까지의 거리
    * 루트의 깊이를 0으로 하는 경우와 1로 하는 경우가 존재
* 높이 (Height)
    * 깊이 중 가장 큰 값
* 조상 (Ancestor) 과 자손 (Descendent)
    * 루트에 가까운 노드가 조상
    * 노드의 조상에는 **자기 자신도 포함**
* 이진 트리 (Binary Tree)
    * 자식을 최대 2개만 가지고 있는 트리

#### 트리의 표현

첫 번째로는, 그래프의 표현과 같은 방식으로 저장할 수 있습니다.  
이 때, E = V - 1 이기 때문에 인접 행렬로 저장하는 것은 비효율적이고 주로 인접 리스트로 저장하게 됩니다.  

두 번째로는, 부모에 해당하는 노드만을 저장하는 방식으로 저장할 수 있습니다.  
이 때, 루트는 부모가 0개이기 때문에 루트의 부모를 0이나 -1로 처리하는 방식을 사용합니다.  
이 경우에 노드의 부모를 찾는 것은 빠르지만, 자식을 찾을 때는 굉장히 오랜 시간이 걸릴 수 있습니다.  

이진 트리 (Binary Tree) 의 경우에는 배열을 통해 저장할 수 있습니다.  
일차원 배열의 경우에는 부모 노드의 인덱스가 X인 경우에, 자식 노드의 인덱스는 2*X, 2*X + 1 로 나타내면 됩니다.  
이차원 배열로 표현할 경우에는 부모 노드 I에 대하여 A[I][0]는 I의 왼쪽 자식 노드, A[I][1]은 I의 오른쪽 자식 노드를 저장할 수 있습니다.  

#### 트리의 순회 (Tree Traversal)

트리도 그래프의 일종이기 때문에 DFS와 BFS를 사용하여 순회가 가능하지만,  
트리의 순회를 위한 세 가지의 방법이 존재합니다.  

1. 전위 순회 (Preorder Traversal) 은 다음과 같은 순서로 진행이 됩니다.  

    1. 노드를 방문  
    2. 왼쪽 자식 노드를 루트로 하는 Subtree Preorder
    3. 오른쪽 자식 노드를 루트로 하는 Subtree Preorder

    전위 순회는 그래프의 DFS와 순서가 같습니다.  

2. 중위 순회 (Inorder Travelsal) 은 다음과 같은 순서로 진행이 됩니다.  

    1. 왼쪽 자식 노드를 루트로 하는 Subtree Inorder
    2. 노드를 방문
    3. 오른쪽 자식 노드를 루트로 하는 Subtree Inorder

    중위 순회는 BST의 Delete 기능 구현에 주로 사용됩니다.  

3. 후위 순회 (Postorder Travelsal) 은 다음과 같은 순서로 진행이 됩니다.  

    1. 왼쪽 자식 노드를 루트로 하는 Subtree Postorder
    2. 오른쪽 자식 노드를 루트로 하는 Subtree Postorder
    3. 노드를 방문